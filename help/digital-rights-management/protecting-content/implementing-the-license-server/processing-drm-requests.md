---
title: Adobe PrimetimeDRM要求の処理
description: Adobe PrimetimeDRM要求の処理
copied-description: true
translation-type: tm+mt
source-git-commit: 89bdda1d4bd5c126f19ba75a819942df901183d1
workflow-type: tm+mt
source-wordcount: '1251'
ht-degree: 0%

---


# Adobe PrimetimeDRM要求の処理{#process-adobe-primetime-drm-requests}

リクエストを管理する一般的な方法は、ハンドラーの作成、リクエストの解析、応答データまたはエラーコードの設定、およびハンドラーの終了です。

単一のリクエスト/応答のインタラクションを処理するために使用される基本クラスは`com.adobe.flashaccess.sdk.protocol.MessageHandlerBase`です。 `HandlerConfiguration`クラスのインスタンスを使用してハンドラーが初期化されます。 `HandlerConfiguration` トランスポート資格情報、タイムスタンプの許容値、ポリシーの更新リスト、失効リストなどのサーバー構成情報を格納します。このハンドラーは、要求データを読み取り、要求を解析して、のインスタンスに渡 `RequestMessageBase`します。呼び出し元は、要求内の情報を調べ、エラーを返すか、応答を成功させるかを判断できる（`RequestMessageBase`のサブクラスが応答データを設定する方法を提供する）。

リクエストが成功した場合は、応答データを設定します。それ以外の場合は、失敗時に`RequestMessageBase.setErrorData()`を呼び出します。 必ず`close()`メソッドを呼び出して実装を終了します（`try`ステートメントの`finally`ブロック内で`close()`を呼び出すことをお勧めします）。 ハンドラーの呼び出し方法の例については、`MessageHandlerBase` APIリファレンスドキュメントを参照してください。

>[!NOTE]
>
>HTTPステータスコード200 (OK)は、ハンドラーが処理するすべての要求に応答して送信する必要があります。 サーバーエラーが原因でハンドラーを作成できなかった場合、サーバーは500 （内部サーバーエラー）など、別のステータスコードで応答する可能性があります。

クライアントは、パッケージ化の際に指定されたライセンスサーバーのURLを、ライセンスサーバーに送信されるすべての要求のベースURLとして使用します。 例えば、サーバーURLを&lt;[!DNL ht<span></span>tps://licenseserver.com/path]>と指定した場合、クライアントは&lt;[!DNL ht<span></span>tps://licenseserver.com/path/flashaccess/...にリクエストを送信します。]>リクエストの各タイプで使用される具体的なパスについて詳しくは、以下の節を参照してください。 ライセンスサーバーを実装する場合は、サーバーが要求の種類ごとに必要なパスに応答することを確認してください。

ライセンスリクエストには、認証トークンを含めることができます。 ユーザー名/パスワード認証を使用した場合、リクエストには`AuthenticationHandler`によって生成された`AuthenticationToken`が含まれている可能性があり、SDKは、ライセンスを発行する前にトークンが有効であることを確認します。

## マシン識別子を使用{#use-machine-identifiers}

すべてのAdobe PrimetimeDRM要求（FMRMS互換性をサポートする要求を除く）には、個別化の際にクライアントに発行されたマシントークンに関する情報が含まれます。 マシントークンには、マシンIDが含まれます。マシンIDは、個別化の際に割り当てられた識別子です。 このIDを使用して、ユーザーがライセンスを要求したマシンまたはドメインに参加したマシンの数をカウントできます。

識別子は次のように使用できます。

* `getUniqueId()`メソッドは、個別化の際にデバイスに割り当てられた文字列を返します。 文字列をデータベースに格納し、識別子で検索できます。 ただし、ユーザーがハードドライブの形式を変更し、再度個別化を行うと、このIDは変更されます。 また、このIDは、同じマシン上の異なるブラウザーでのAdobe AIRとAdobeのFlash Playerの間でも異なる値を持ちます。
* もっと正確にマシンをカウントしたい場合は、`getBytes()`を使って識別子全体を保存してください。 マシンが以前に見られたかどうかを判断するには、ユーザー名の識別子をすべて取得し、`matches()`を呼び出して、一致するかどうかを確認します。 `matches()`メソッドは`MachineId.getBytes`が返す値を比較するために使用する必要があるので、比較対象の値が少数ある場合にのみ実用的です。例えば、特定のユーザーに関連付けられたマシンなどです。

## ユーザー認証{#user-authentication}

Adobe PrimetimeのDRMリクエストには、認証トークンを含めることができます。

ユーザー名/パスワード認証を使用した場合は、`AuthenticationHandler`によって生成された`AuthenticationToken`がリクエストに含まれる可能性があります。 トークンにアクセスして確認する場合は、`RequestMessageBase.getAuthenticationToken()`を使用する必要があります。 クライアントでユーザー名/パスワードの要求を開始するには、`DRMManager.authenticate()`ActionScriptまたはiOS APIを使用します。

クライアントおよびサーバーがカスタム認証メカニズムを使用する場合、クライアントは他のチャネルを介して認証トークンを取得し、`DRMManager.setAuthenticationToken`ActionScript3.0 APIを使用してカスタム認証トークンを設定します。 `RequestMessageBase.getRawAuthenticationToken()`を使用して、カスタム認証トークンを取得します。 サーバーの実装によって、カスタム認証トークンが有効かどうかが決まります。

## 再生保護{#replay-protection}

リプレイ保護のため、`RequestMessageBase.getMessageId()`を呼び出して、メッセージIDが最近表示されたかどうかを確認できます。 その場合、攻撃者は要求を再生しようとしている可能性がありますが、これは拒否されるはずです。 再生試行を検出するために、サーバーは最近表示されたメッセージIDのリストを格納し、キャッシュされたリストに対して各着信要求を確認できます。 メッセージ識別子の保存時間を制限するには、`HandlerConfiguration.setTimestampTolerance()`を呼び出します。 このプロパティを設定すると、SDKは、指定された秒数を超えるタイムスタンプをサーバー時間から送信する要求を拒否します。

## ロールバックの検出{#rollback-detection}

ロールバック検出の場合、一部の使用ルールでは、権限を適用するためにクライアントが状態情報を維持する必要があります。 例えば、再生ウィンドウの使用ルールを適用するために、クライアントは、ユーザーがコンテンツの最初の表示を開始した日時を保存します。 このイベントは、再生ウィンドウの開始をトリガーします。 再生ウィンドウを安全に強制するには、クライアントに保存されている再生ウィンドウの開始時間を削除するために、ユーザーがクライアント状態のバックアップおよび復元を行わないようにする必要があります。 サーバーは、クライアントのロールバックカウンターの値を追跡することでこれを行います。

リクエストごとに、サーバーは`RequestMessageBase.getClientState()`を呼び出して`ClientState`オブジェクトを取得し、`ClientState.getCounter()`を呼び出してクライアント状態カウンターの現在の値を取得することで、カウンターの値を取得します。 サーバーは、各クライアントにこの値を格納する必要があります（`MachineId.getUniqueId()`を使用してロールバックカウンタ値に関連付けられたクライアントを識別します）。次に`ClientState.incrementCounter()`を呼び出してカウンタ値を1ずつ増やします。 カウンター値がサーバーで最後に表示された値より小さいことがサーバーで検出された場合は、クライアント状態がロールバックされた可能性があります。

クライアント状態の改ざん検出について詳しくは、`ClientState` APIリファレンスドキュメントを参照してください。

## グローバル・サーバ構成データ{#global-server-configuration-data}

ライセンスサーバーが使用する構成に加えて、`HandlerConfiguration`には、ライセンスの適用方法を制御するためにクライアントに送信できる構成情報が格納されます。 これは、`ServerConfigData`クラスを作成し、`HandlerConfiguration.setServerConfigData()`を呼び出すことで行います。 これらの設定は、このライセンスサーバーが発行したライセンスにのみ適用されます。

クロックウィンドバック許容値は、ライセンスサーバーがクライアントによるライセンスの強制方法を制御するために設定できる1つのプロパティです。 デフォルトでは、ユーザーはライセンスを無効にすることなく、コンピューターのクロックを4時間戻すことができます。 ライセンスサーバーの演算子が別の設定を使用したい場合は、新しい値を`ServerConfigData`クラスに設定できます。 これらの設定の値を変更する場合は、必ず`setVersion()`を呼び出してバージョン番号を増やしてください。 新しい値は、クライアント上のバージョンが現在の`ServerConfigData`バージョンより古い場合にのみクライアントに送信されます。

## クロスドメインDRMポリシーファイル{#crossdomain-drm-policy-file}

ライセンスサーバーがビデオ再生SWFとは異なるドメインでホストされている場合は、SWFがライセンスサーバーからライセンスを要求できるようにするために、クロスドメインDRMポリシーファイル([!DNL crossdomain.xml])が必要です。 クロスドメインDRMポリシーファイルはXMLファイルで表されます。XMLファイルを使用すると、サーバーは、他のドメインから提供されたSWFファイルでそのデータとドキュメントを使用できることを示すことができます。 ライセンスサーバーのクロスドメインDRMポリシーファイルで指定されたドメインから提供されるSWFファイルは、そのライセンスサーバーのデータまたはアセットにアクセスできます。

Adobeでは、クロスドメインポリシーファイルを展開する際に、ベストプラクティスに従って、信頼されたドメインだけがライセンスサーバーにアクセスでき、Webサーバー上のライセンスサブディレクトリへのアクセスを制限することを推奨します。

クロスドメインDRMポリシーファイルについて詳しくは、次の場所を参照してください。

* Webサイトコントロール（DRMポリシーファイル）
* クロスドメインDRMポリシーファイルの仕様：[https://www.adobe.com/devnet/articles/crossdomain_policy_file_spec.html](https://www.adobe.com/devnet/articles/crossdomain_policy_file_spec.html)