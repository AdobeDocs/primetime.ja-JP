---
seo-title: Adobe Primetime DRMリクエストの処理
title: Adobe Primetime DRMリクエストの処理
uuid: ee10504d-84f0-472a-b58a-2a87fdeedfc1
translation-type: tm+mt
source-git-commit: c78d3c87848943a0be3433b2b6a543822a7e1c15

---


# Adobe Primetime DRMリクエストの処理 {#process-adobe-primetime-drm-requests}

リクエストを管理する一般的な方法は、ハンドラーを作成し、リクエストを解析し、応答データまたはエラーコードを設定して、ハンドラーを閉じることです。

単一のリクエスト/応答のインタラクションを処理するために使用される基本クラスはで `com.adobe.flashaccess.sdk.protocol.MessageHandlerBase`す。 クラスのインスタンス `HandlerConfiguration` を使用してハンドラーが初期化されます。 `HandlerConfiguration` は、トランスポート資格情報、タイムスタンプの許容値、ポリシーの更新リスト、失効リストなどのサーバー構成情報を格納します。ハンドラーは、要求データを読み取り、要求を解析して、のインスタンスに取り込みま `RequestMessageBase`す。 呼び出し元は、リクエスト内の情報を調べ、エラーを返すか、成功した応答を返すかを決定できます(のサブクラスは、応答デ `RequestMessageBase` ータを設定する方法を提供します)。

リクエストが成功した場合は、応答データを設定します。それ以外の場合は、失 `RequestMessageBase.setErrorData()` 敗時に呼び出します。 メソッドを呼び出すことで、必ず実 `close()` 装を終了します(ステートメ `close()` ントのブロック内で呼び出す `finally` ことをお勧 `try` めします)。 ハンドラーの呼び出し方法の例については、 `MessageHandlerBase` APIリファレンスドキュメントを参照してください。

>[!NOTE] {class=&quot;- topic/note &quot;}
>
>HTTPステータスコード200 (OK)は、ハンドラーで処理されるすべての要求に応じて送信されます。 サーバーエラーが原因でハンドラーを作成できなかった場合、サーバーは500 （内部サーバーエラー）などの別のステータスコードで応答する可能性があります。

クライアントは、パッケージ化時に指定されたライセンスサーバのURLを、ライセンスサーバに送信されるすべての要求のベースURLとして使用します。 例えば、サーバーURLを&lt;[!DNL ht<span></span>tps://licenseserver.com/path]>と指定した場合、クライアントは&lt;[!DNL ht<span></span>tps://licenseserver.com/path/flashaccess/...]>にリクエストを送信します。各リクエストのタイプで使用される特定のパスの詳細については、以下の節を参照してください。 ライセンスサーバーを実装する場合は、各要求タイプに必要なパスにサーバーが応答することを確認します。

ライセンス要求には、認証トークンを含めることができます。 ユーザー名/パスワード認証が使用された場合、リクエストには、によって生成されたものが含まれてい `AuthenticationToken` る可能性があり、SDKは、ライ `AuthenticationHandler`センスを発行する前にトークンが有効であることを確認します。

## マシン識別子を使用 {#use-machine-identifiers}

（FMRMS互換性をサポートするリクエストを除く）すべてのAdobe Primetime DRMリクエストには、個別化の際にクライアントに発行されたマシントークンに関する情報が含まれます。 マシントークンには、個別化の際に割り当てられたマシンIDが含まれます。 この識別子を使用して、ユーザーがライセンスを要求した、またはドメインに参加したマシンの数をカウントできます。

識別子は、次のように使用できます。

* このメ `getUniqueId()` ソッドは、個別化の際にデバイスに割り当てられた文字列を返します。 文字列をデータベースに格納し、識別子で検索できます。 ただし、ユーザーがハードドライブを再フォーマットし、再度個別化すると、この識別子は変更されます。 また、この識別子の値は、同じマシン上の異なるブラウザーのAdobe AIRとAdobe Flash Playerの間でも異なります。
* マシンをより正確にカウントしたい場合は、を使用して識別子全 `getBytes()` 体を保存することができます。 マシンが以前に表示されたことがあるかどうかを確認するには、ユーザー名のすべての識別子を取得し、が呼び出されて一致 `matches()` するかどうかを確認します。 メソッド `matches()` を使用してによって返される値を比較する必要があるので、このオ `MachineId.getBytes`プションは比較する値の数が少ない場合にのみ実用的です。例えば、特定のユーザーに関連付けられたマシンなどです。

## ユーザー認証 {#user-authentication}

Adobe Primetime DRMリクエストには、認証トークンを含めることができます。

ユーザー名/パスワード認証を使用した場合、リクエストには、 `AuthenticationToken``AuthenticationHandler`トークンにアクセスして確認する場合は、を使用する必要がありま `RequestMessageBase.getAuthenticationToken()`す。 クライアント上でユーザー名/パスワードのリクエストを開始するには、 `DRMManager.authenticate()` ActionScriptまたはiOS APIを使用します。

クライアントとサーバーがカスタム認証メカニズムを使用する場合、クライアントは他のチャネルを通じて認証トークンを取得し、 `DRMManager.setAuthenticationToken` ActionScript 3.0 APIを使用してカスタム認証トークンを設定します。 を使用し `RequestMessageBase.getRawAuthenticationToken()` て、カスタム認証トークンを取得します。 サーバーの実装によって、カスタム認証トークンが有効かどうかが決まります。

## 再生保護 {#replay-protection}

再生保護のために、を呼び出して、メッセージ識別子が最近表示されたかどうかを確認できま `RequestMessageBase.getMessageId()`す。 その場合、攻撃者が要求を再実行しようとしている可能性がありますが、これは拒否される必要があります。 再生試行を検出するために、サーバーは最近表示されたメッセージIDのリストを格納し、受信要求をキャッシュされたリストと比較して確認できます。 メッセージ識別子の保存時間を制限するには、を呼び出しま `HandlerConfiguration.setTimestampTolerance()`す。 このプロパティが設定されている場合、SDKは、指定された秒数を超えるタイムスタンプを持つ要求を拒否します。

## ロールバックの検出 {#rollback-detection}

ロールバック検出の場合、一部の使用ルールでは、権限を適用するためにクライアントが状態情報を維持する必要があります。 例えば、再生ウィンドウの使用ルールを強制するために、クライアントは、ユーザーがコンテンツの最初の表示を開始した日時を保存します。 このイベントは、再生ウィンドウの開始をトリガーします。 再生ウィンドウを安全に強制するには、クライアントに保存されている再生ウィンドウの開始時間を削除するために、ユーザーがクライアントの状態をバックアップおよび復元しないようにする必要があります。 サーバは、クライアントのロールバックカウンタの値を追跡することで、これを行います。

要求ごとに、サーバーは、を呼び出してオブジェクトを取得し、次にを呼び出して、ク `RequestMessageBase.getClientState()` ライアント状態カ `ClientState` ウンタ `ClientState.getCounter()` ーの現在の値を取得することで、カウンターの値を取得します。 サーバは、各クライアントにこの値を格納し(ロールバックカウンタ値に関連付けられ `MachineId.getUniqueId()` たクライアントを識別するために使用)、次にを呼び出してカ `ClientState.incrementCounter()` ウンタ値を1ずつ増やす必要があります。 カウンタ値がサーバーで最後に表示された値より小さいことをサーバーが検出した場合は、クライアントの状態がロールバックされている可能性があります。

クライアント状態の改ざん検出について詳しくは、 `ClientState` APIリファレンスドキュメントを参照してください。

## グローバルサーバ設定データ{#global-server-configuration-data}

ライセンスサーバーで使用される設定に加えて、は、ライ `HandlerConfiguration` センスの適用方法を制御するためにクライアントに送信できる設定情報を保存します。 これは、クラスを作成して呼び出す `ServerConfigData` ことで行われま `HandlerConfiguration.setServerConfigData()`す。 これらの設定は、このライセンスサーバーが発行したライセンスにのみ適用されます。

クロックのウィンドバック許容値は、クライアントがライセンスを強制する方法を制御するためにライセンスサーバーが設定できる1つのプロパティです。 デフォルトでは、ユーザーはライセンスを無効にすることなく、コンピューターのクロックを4時間戻すことができます。 ライセンスサーバーのオペレータが別の設定を使用する場合、新しい値をクラスに設定でき `ServerConfigData` ます。 これらの設定の値を変更する場合は、を呼び出してバージョン番号を増やしてくださ `setVersion()`い。 新しい値は、クライアント上のバージョンが現在のバージョンより古い場合にのみクライアントに送信さ `ServerConfigData` れます。

## クロスドメインDRMポリシーファイル {#crossdomain-drm-policy-file}

ライセンスサーバーがビデオ再生SWFとは異なるドメインでホストされている場合は、SWFがライセンスサーバーのライセンスを要求できるようにするために、クロスドメインDRMポリシーファイル( [!DNL crossdomain.xml])が必要です。 クロスドメインDRMポリシーファイルはXMLファイルで表されます。このファイルを使用すると、サーバーは、他のドメインから提供されたSWFファイルでそのデータとドキュメントを使用できることを示すことができます。 ライセンスサーバーのクロスドメインDRMポリシーファイルで指定されたドメインから提供されるSWFファイルは、そのライセンスサーバーのデータまたはアセットにアクセスできます。

アドビでは、クロスドメインポリシーファイルを展開する際に、信頼されたドメインのみがライセンスサーバーにアクセスでき、Webサーバー上のライセンスサブディレクトリへのアクセスを制限することで、開発者にベストプラクティスに従うことを推奨します。

クロスドメインDRMポリシーファイルについて詳しくは、次の場所を参照してください。

* Webサイトのコントロール（DRMポリシーファイル）
* クロスドメインDRMポリシーファイルの仕様：https://www.adobe.com/devnet/articles/crossdomain_policy_file_spec.html [](https://www.adobe.com/devnet/articles/crossdomain_policy_file_spec.html)