---
seo-title: Adobe PrimetimeDRM要求の処理
title: Adobe PrimetimeDRM要求の処理
uuid: ee10504d-84f0-472a-b58a-2a87fdeedfc1
translation-type: tm+mt
source-git-commit: 1b9792a10ad606b99b6639799ac2aacb707b2af5
workflow-type: tm+mt
source-wordcount: '1251'
ht-degree: 0%

---


# Adobe PrimetimeDRM要求の処理 {#process-adobe-primetime-drm-requests}

リクエストを管理する一般的な方法は、ハンドラーの作成、リクエストの解析、応答データまたはエラーコードの設定、およびハンドラーの終了です。

単一のリクエスト/応答のインタラクションを処理するために使用される基本クラスは `com.adobe.flashaccess.sdk.protocol.MessageHandlerBase`です。 クラスのインスタンスを使用して、ハンドラーを初期化し `HandlerConfiguration` ます。 `HandlerConfiguration` トランスポート資格情報、タイムスタンプの許容値、ポリシーの更新リスト、失効リストなどのサーバー構成情報を格納します。このハンドラーは、要求データを読み取り、要求を解析して、のインスタンスに渡 `RequestMessageBase`します。 呼び出し元は、リクエスト内の情報を調べ、エラーを返すか、正常な応答を返すかを決定できます(応答データを設定するためのメソッドを `RequestMessageBase` 提供するサブクラス)。

リクエストが成功した場合は、応答データを設定します。それ以外の場合は、失敗 `RequestMessageBase.setErrorData()` 時に呼び出します。 メソッドを呼び出すことで、必ず実装を終了します(ステートメントの `close()` ブロック内で呼び出すこ `close()` とをお勧めし `finally``try` ます)。 ハンドラーの呼び出し方法の例については、 `MessageHandlerBase` APIリファレンスドキュメントを参照してください。

>[!NOTE]
>
>HTTPステータスコード200 (OK)は、ハンドラーが処理するすべての要求に応答して送信する必要があります。 サーバーエラーが原因でハンドラーを作成できなかった場合、サーバーは500 （内部サーバーエラー）など、別のステータスコードで応答する可能性があります。

クライアントは、パッケージ化の際に指定されたライセンスサーバーのURLを、ライセンスサーバーに送信されるすべての要求のベースURLとして使用します。 例えば、サーバーURLを&lt;tps://licenseserver.com/path[!DNL ht<span></span>>と指定した場合、クライアントは&lt;]tps://licenseserver.com/path/flashaccess/[!DNL ht<span></span>..]>にリクエストを送信します。各リクエストタイプで使用される具体的なパスの詳細については、以下の節を参照してください。 ライセンスサーバーを実装する場合は、サーバーが要求の種類ごとに必要なパスに応答することを確認してください。

ライセンスリクエストには、認証トークンを含めることができます。 ユーザー名とパスワードの認証を使用した場合、リクエストにはによって `AuthenticationToken` 生成された認証が含まれ `AuthenticationHandler`ている可能性があり、SDKは、ライセンスを発行する前にトークンが有効であることを確認します。

## マシン識別子を使用する {#use-machine-identifiers}

すべてのAdobe PrimetimeDRM要求（FMRMS互換性をサポートする要求を除く）には、個別化の際にクライアントに発行されたマシントークンに関する情報が含まれます。 マシントークンには、マシンIDが含まれます。マシンIDは、個別化の際に割り当てられた識別子です。 このIDを使用して、ユーザーがライセンスを要求したマシンまたはドメインに参加したマシンの数をカウントできます。

識別子は次のように使用できます。

* この `getUniqueId()` メソッドは、個別化の際にデバイスに割り当てられた文字列を返します。 文字列をデータベースに格納し、識別子で検索できます。 ただし、ユーザーがハードドライブの形式を変更し、再度個別化を行うと、このIDは変更されます。 また、このIDは、同じマシン上の異なるブラウザーでのAdobe AIRとAdobeのFlash Playerの間でも異なる値を持ちます。
* マシンをより正確にカウントしたい場合は、を使用して識別子全体 `getBytes()` を保存できます。 マシンが以前に確認されたかどうかを確認するには、ユーザー名のすべての識別子を取得し、一致するかどうかを確認す `matches()` るための呼び出しを行います。 この `matches()` メソッドは、が返す値を比較するために使用する必要があるので、比較対象の値が少数ある場合にの `MachineId.getBytes`み実用的です。例えば、特定のユーザーに関連付けられたマシンなどです。

## ユーザー認証 {#user-authentication}

Adobe PrimetimeのDRMリクエストには、認証トークンを含めることができます。

ユーザー名/パスワード認証を使用した場合は、によって `AuthenticationToken` 生成されたIDをリクエストに含めることができ `AuthenticationHandler`ます。 トークンにアクセスして確認する場合は、を使用する必要があり `RequestMessageBase.getAuthenticationToken()`ます。 クライアントでユーザー名/パスワードの要求を開始するには、 `DRMManager.authenticate()` ActionScriptまたはiOS APIを使用します。

クライアントおよびサーバーがカスタム認証メカニズムを使用する場合、クライアントは他のチャネルを介して認証トークンを取得し、 `DRMManager.setAuthenticationToken` ActionScript3.0 APIを使用してカスタム認証トークンを設定します。 を使用 `RequestMessageBase.getRawAuthenticationToken()` して、カスタム認証トークンを取得します。 サーバーの実装によって、カスタム認証トークンが有効かどうかが決まります。

## 再生保護 {#replay-protection}

リプレイ保護の場合は、を呼び出して、メッセージIDが最近表示されたかどうかを確認でき `RequestMessageBase.getMessageId()`ます。 その場合、攻撃者は要求を再生しようとしている可能性がありますが、これは拒否されるはずです。 再生試行を検出するために、サーバーは最近表示されたメッセージIDのリストを格納し、キャッシュされたリストに対して各着信要求を確認できます。 メッセージ識別子を保存する必要がある時間を制限するには、を呼び出し `HandlerConfiguration.setTimestampTolerance()`ます。 このプロパティを設定すると、SDKは、指定された秒数を超えるタイムスタンプをサーバー時間から送信する要求を拒否します。

## ロールバックの検出 {#rollback-detection}

ロールバック検出の場合、一部の使用ルールでは、権限を適用するためにクライアントが状態情報を維持する必要があります。 例えば、再生ウィンドウの使用ルールを適用するために、クライアントは、ユーザーがコンテンツの最初の表示を開始した日時を保存します。 このイベントは、再生ウィンドウの開始をトリガーします。 再生ウィンドウを安全に強制するには、クライアントに保存されている再生ウィンドウの開始時間を削除するために、ユーザーがクライアント状態のバックアップおよび復元を行わないようにする必要があります。 サーバーは、クライアントのロールバックカウンターの値を追跡することでこれを行います。

要求ごとに、サーバーは、を呼び出して `RequestMessageBase.getClientState()` オブジェクトを取得し、を呼び出して、カウンターの値を取得し、を呼び出して、クライアント状態カウンター `ClientState``ClientState.getCounter()` の現在の値を取得します。 サーバーは、各クライアントにこの値を格納する必要があります(ロールバックカウンタ値に関連付けられ `MachineId.getUniqueId()` たクライアントを識別するために使用)。次に、を呼び出してカウンタ値 `ClientState.incrementCounter()` を1ずつ増やします。 カウンター値がサーバーで最後に表示された値より小さいことがサーバーで検出された場合は、クライアント状態がロールバックされた可能性があります。

クライアント状態の改ざん検出について詳しくは、 `ClientState` APIリファレンスドキュメントを参照してください。

## グローバルサーバー設定データ{#global-server-configuration-data}

ライセンスサーバで使用される設定に加えて、には、ライセンスの適用方法を制御するためにクライアントに送信できる設定情報も `HandlerConfiguration` 格納されます。 これは、 `ServerConfigData` クラスを作成してを呼び出すことで行われ `HandlerConfiguration.setServerConfigData()`ます。 これらの設定は、このライセンスサーバーが発行したライセンスにのみ適用されます。

クロックウィンドバック許容値は、ライセンスサーバーがクライアントによるライセンスの強制方法を制御するために設定できる1つのプロパティです。 デフォルトでは、ユーザーはライセンスを無効にすることなく、コンピューターのクロックを4時間戻すことができます。 ライセンスサーバーのオペレーターが別の設定を使用したい場合は、新しい値を `ServerConfigData` クラスに設定できます。 これらの設定の値を変更する場合は、を呼び出してバージョン番号を増やす必要があり `setVersion()`ます。 新しい値は、クライアント上のバージョンが現在のバージョンより古い場合にのみクライアントに送信され `ServerConfigData` ます。

## Crossdomain DRMポリシーファイル {#crossdomain-drm-policy-file}

ライセンスサーバーがビデオ再生SWFとは異なるドメインでホストされている場合は、SWFがライセンスサーバーからライセンスを要求できるように、クロスドメインDRMポリシーファイル( [!DNL crossdomain.xml])が必要です。 クロスドメインDRMポリシーファイルはXMLファイルで表されます。XMLファイルを使用すると、サーバーは、他のドメインから提供されたSWFファイルでそのデータとドキュメントを使用できることを示すことができます。 ライセンスサーバーのクロスドメインDRMポリシーファイルで指定されたドメインから提供されるSWFファイルは、そのライセンスサーバーのデータまたはアセットにアクセスできます。

Adobeでは、クロスドメインポリシーファイルを展開する際に、ベストプラクティスに従って、信頼されたドメインだけがライセンスサーバーにアクセスでき、Webサーバー上のライセンスサブディレクトリへのアクセスを制限することを推奨します。

クロスドメインDRMポリシーファイルについて詳しくは、次の場所を参照してください。

* Webサイトコントロール（DRMポリシーファイル）
* クロスドメインDRMポリシーファイルの仕様： [https://www.adobe.com/devnet/articles/crossdomain_policy_file_spec.html](https://www.adobe.com/devnet/articles/crossdomain_policy_file_spec.html)